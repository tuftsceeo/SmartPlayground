## DO NOT EDIT THIS FILE

"""
Smart Playground Control - Web Bluetooth API Wrapper

This module provides a Python wrapper for the Web Bluetooth API, enabling
PyScript applications to communicate with Bluetooth Low Energy (BLE) devices
directly from the browser. It specifically implements the Nordic UART Service
for communication with ESP32 devices.

Key Features:
- Web Bluetooth API integration for browser-based BLE communication
- Nordic UART Service implementation for ESP32 compatibility
- Automatic device discovery and connection management
- Bidirectional data transmission (send/receive)
- Event-driven notification handling for incoming data
- Proper resource cleanup and memory management

BLE Service Details:
- Service UUID: 6e400001-b5a3-f393-e0a9-e50e24dcca9e (Nordic UART)
- TX Characteristic: 6e400003-b5a3-f393-e0a9-e50e24dcca9e (device→browser)
- RX Characteristic: 6e400002-b5a3-f393-e0a9-e50e24dcca9e (browser→device)

Usage Pattern:
1. Create WebBLE instance
2. Connect to device by name or service UUID
3. Set up data callback for incoming notifications
4. Send/receive data as needed
5. Disconnect and cleanup when done

Communication Protocol:
- Text-based messaging with newline termination
- JSON format for structured data exchange
- UTF-8 encoding for all text transmission
- Automatic reconnection handling for reliability
"""

code = '''
# This code runs in the BROWSER using PyScript, not on the ESP32
from pyscript import window
import asyncio

class WebBLE:
    def __init__(self):
        # Nordic UART Service UUIDs (matching ble_ceeo_lib.py)
        # MUST be lowercase for Web Bluetooth API
        self.service_uuid = '6e400001-b5a3-f393-e0a9-e50e24dcca9e'
        self.tx_uuid = '6e400003-b5a3-f393-e0a9-e50e24dcca9e'  # RX from device perspective
        self.rx_uuid = '6e400002-b5a3-f393-e0a9-e50e24dcca9e'  # TX from device perspective
        
        self.device = None
        self.server = None
        self.service = None
        self.tx_char = None  # For receiving notifications from ESP32
        self.rx_char = None  # For writing to ESP32
        self.on_data_callback = None
        
    async def connect(self, name_prefix='ESP32'):
        """Connect to BLE device by name prefix"""
        try:
            print("Requesting Bluetooth device...")
            
            # Check if Bluetooth is available
            if not hasattr(window.navigator, 'bluetooth'):
                print("ERROR: Web Bluetooth API not available!")
                print("Make sure you are using Chrome/Edge and the page is HTTPS or localhost")
                return False
            
            # Request device with filters
            options = window.Object.new()
            options.filters = [window.Object.new()]
            options.filters[0].namePrefix = name_prefix
            options.optionalServices = [self.service_uuid]
            
            print(f"Looking for devices with name prefix: {name_prefix}")
            self.device = await window.navigator.bluetooth.requestDevice(options)
            
            if not self.device:
                print("No device selected")
                return False
                
            print(f"Selected device: {self.device.name}")
            
            # Connect to GATT server
            print("Connecting to GATT server...")
            self.server = await self.device.gatt.connect()
            print("Connected to GATT server")
            
            # Get service
            print(f"Getting service {self.service_uuid}...")
            self.service = await self.server.getPrimaryService(self.service_uuid)
            print("Got service")
            
            # Get characteristics
            print("Getting characteristics...")
            self.tx_char = await self.service.getCharacteristic(self.tx_uuid)
            self.rx_char = await self.service.getCharacteristic(self.rx_uuid)
            print("Got characteristics")
            
            # Start notifications
            print("Starting notifications...")
            await self.tx_char.startNotifications()
            # Create proxy for event listener to prevent garbage collection
            from pyodide.ffi import create_proxy
            self.notification_proxy = create_proxy(self._on_notification)
            self.tx_char.addEventListener('characteristicvaluechanged', self.notification_proxy)
            print("Notifications started - Connected!")
            
            return True
            
        except Exception as e:
            # Handle specific user cancellation error
            error_msg = str(e)
            if ("User cancelled" in error_msg or 
                "NotAllowedError" in error_msg or 
                "AbortError" in error_msg or
                "cancelled" in error_msg.lower()):
                print("User cancelled BLE connection dialog - this is normal")
                return False
            else:
                print(f"Connection error: {e}")
                import traceback
                traceback.print_exc()
                return False
    
    async def connect_by_service(self):
        """Connect to BLE device by service UUID - finds any device with Nordic UART service"""
        try:
            print("Requesting Bluetooth device by service UUID...")
            
            # Check if Bluetooth is available
            if not hasattr(window.navigator, 'bluetooth'):
                print("ERROR: Web Bluetooth API not available!")
                return False
            
            # Request device filtering by service UUID only
            options = window.Object.new()
            options.filters = [window.Object.new()]
            options.filters[0].services = [self.service_uuid]
            
            print(f"Looking for devices with service: {self.service_uuid}")
            self.device = await window.navigator.bluetooth.requestDevice(options)
            
            if not self.device:
                print("No device selected")
                return False
                
            print(f"Selected device: {self.device.name}")
            
            # Connect to GATT server
            print("Connecting to GATT server...")
            self.server = await self.device.gatt.connect()
            print("Connected to GATT server")
            
            # Get service
            print(f"Getting service {self.service_uuid}...")
            self.service = await self.server.getPrimaryService(self.service_uuid)
            print("Got service")
            
            # Get characteristics
            print("Getting characteristics...")
            self.tx_char = await self.service.getCharacteristic(self.tx_uuid)
            self.rx_char = await self.service.getCharacteristic(self.rx_uuid)
            print("Got characteristics")
            
            # Start notifications
            print("Starting notifications...")
            await self.tx_char.startNotifications()
            # Create proxy for event listener to prevent garbage collection
            from pyodide.ffi import create_proxy
            self.notification_proxy = create_proxy(self._on_notification)
            self.tx_char.addEventListener('characteristicvaluechanged', self.notification_proxy)
            print("Notifications started - Connected!")
            
            return True
            
        except Exception as e:
            # Handle specific user cancellation error
            error_msg = str(e)
            if ("User cancelled" in error_msg or 
                "NotAllowedError" in error_msg or 
                "AbortError" in error_msg or
                "cancelled" in error_msg.lower()):
                print("User cancelled BLE connection dialog - this is normal")
                return False
            else:
                print(f"Connection error: {e}")
                import traceback
                traceback.print_exc()
                return False
    
    def _on_notification(self, event):
        """Handle incoming notifications from ESP32"""
        try:
            value = event.target.value
            # Convert DataView to string
            decoder = window.TextDecoder.new()
            text = decoder.decode(value)
            print(f"Received: {text}")
            
            if self.on_data_callback:
                self.on_data_callback(text)
        except Exception as e:
            print(f"Notification error: {e}")
    
    async def send(self, message):
        """Send data to ESP32"""
        if not self.rx_char:
            print("Not connected!")
            return False
            
        try:
            # Convert string to bytes
            encoder = window.TextEncoder.new()
            data = encoder.encode(message + "\\n")
            await self.rx_char.writeValue(data)
            print(f"Sent: {message}")
            return True
        except Exception as e:
            print(f"Send error: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    async def disconnect(self):
        """Disconnect from device"""
        try:
            if self.device and self.device.gatt.connected:
                await self.device.gatt.disconnect()
                print("Disconnected")
        except Exception as e:
            print(f"Disconnect error: {e}")
        finally:
            # Clean up proxy to prevent memory leaks
            if hasattr(self, 'notification_proxy'):
                self.notification_proxy.destroy()
                self.notification_proxy = None
            self.device = None
            self.server = None
            self.service = None
            self.tx_char = None
            self.rx_char = None
    
    def is_connected(self):
        """Check if connected"""
        return self.device and self.device.gatt.connected
'''
